#!/usr/bin/env python
import os
import os.path
import sys
import time
import shlex
import signal
import subprocess
from logger.log_module import *

PIDFILE = '/tmp/process.pid'
MYSQL_PIDFILE = '/opt/TopPatch/mysql/percona-5.5/data/ubuntu.pid'
MYSQL_SERVER = '/opt/TopPatch/mysql/percona-5.5/support-files/mysql.server'
PATH='/opt/TopPatch/tp/'
TPLISTENER = 'src/receiver/rvlistener.py'
CSRLISTENER = 'src/receiver/csrlistener.py'
TOPPATCH = 'src/toppatch.py'
PROGRAM = 'python'

TopPatch_SERVICES = [TPLISTENER, CSRLISTENER, TOPPATCH]


def run(program, *args):
    try:
        pid = os.fork()
        if not pid:
            os.execvp(program, (program,) + args)
    except OSError, e:
        sys.stderr.write("fork failed %d (%s)\n" % (e.errno, e.strerror))
        logger.warning("fork failed %d (%s)\n" % (e.errno, e.strerror))    
        sys.exit(1)
    return pid


def mysql_start(mysql_server, mysql_pidfile):
    start_cmd = '%s start' % mysql_server
    start = shlex.split(start_cmd)
    subprocess.call(start, stdout=subprocess.PIPE)
    get_pid = shlex.split('cat %s' % mysql_pidfile)
    mysql_pid = subprocess.Popen(get_pid, stdout=subprocess.PIPE)
    pid = mysql_pid.communicate()[0].strip()
    return pid


def mysql_stop(mysql_server):
    stop_cmd = '%s stop' % mysql_server
    stop = shlex.split(stop_cmd)
    subprocess.call(stop, stdout=subprocess.PIPE)


def handler(signum, frame):
    print "returning back to terminal"


def TopPatch_start():
    pids = []
    if os.path.isfile(PIDFILE) and os.path.isfile(MYSQL_PIDFILE):
        pf = file(PIDFILE, 'r')
        pids = (pf.read().strip()[1:-1])
        pid_no = pids.split(', ')
        pf.close()
        count = 0
        for pid in pid_no:
            if pid:
                count = count + 1
        if count == len(pid_no):
            message = "TopPatch Server is already running. Pidfile: '%s'\n"
            sys.stderr.write(message % PIDFILE)
            logger.info(message % PIDFILE)
            sys.exit(1)
    else:
	os.chdir(PATH)
        print 'TopPatch Server is starting. Please wait....'
        logger.info('TopPatch Server is starting. Please wait....')
        mysql_pid = mysql_start(MYSQL_SERVER, MYSQL_PIDFILE)
        logger.info("Mysql Server Started")
        pids.append(mysql_pid)
        time.sleep(1)
        for service in TopPatch_SERVICES:
            pid = run(PROGRAM, service)
            pids.append(pid)
            time.sleep(1)
        file(PIDFILE, 'w+').write("%s\n" % pids)
        signal.signal(signal.SIGINT, handler)
        time.sleep(5)
        print 'TopPatch Server has been started. Enjoy !!!'
        logger.info('TopPatch Server has been started. Enjoy !!!')


def TopPatch_stop():
    if not os.path.isfile(PIDFILE):
        message = "TopPatch Server is not running. Stopping Failed...\n"
        sys.stderr.write(message)
        logger.error("TopPatch server is not running. Stopping Failed...")
        sys.exit(1)
    else:
        print 'TopPatch Server is going to stop now....'
        logger.info('TopPatch Server is going to stop now...')
        pf = file(PIDFILE, 'r')
        pids = (pf.read().strip()[1:-1])
        pid_no = pids.split(', ')
        pf.close()
        os.kill(int(pid_no[1]), signal.SIGTERM)
        time.sleep(2)
        os.kill(int(pid_no[2]), signal.SIGTERM)
        time.sleep(2)
	os.kill(int(pid_no[3]), signal.SIGTERM)
	time.sleep(2)
        mysql_stop(MYSQL_SERVER)
        os.remove(PIDFILE)
        print 'TopPatch Server has been stopped now !!!'
        logger.info('TopPatch Server has been stopped now !!!')


def TopPatch_restart():
    TopPatch_stop()
    print "\n"	
    TopPatch_start()


def TopPatch_status():
    if os.path.isfile(PIDFILE):
        message = "TopPatch Server is running and the PIDFILE is: '%s'\n"
        sys.stderr.write(message % PIDFILE)
        logger.info(message % PIDFILE)
        sys.exit(1)
    else:
        print "TopPatch Server is not running."
        logger.info("TopPatch Server is not running.")
        sys.exit(2)

ACTIONS = sys.argv[1]

if __name__ == "__main__":
    if len(sys.argv) == 2:
        if ACTIONS == 'start':
            TopPatch_start()
        elif ACTIONS == 'stop':
            TopPatch_stop()
        elif ACTIONS == 'restart':
            TopPatch_restart()
            logger.info("TopPatch server restarting..")
        elif ACTIONS == 'status':
            TopPatch_status()
        else:
            print "Unknown command"
            sys.exit(2)
        sys.exit(0)
    else:
        print "usage: %s start|stop|restart|status" % sys.argv[0]
